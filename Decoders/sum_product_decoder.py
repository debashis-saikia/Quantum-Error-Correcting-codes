# -*- coding: utf-8 -*-
"""Sum Product Decoder.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1svTef2RuMjeuELBhkNPHwmNHjTWThR12
"""

import numpy as np

def decoder(e, max_iter, bitstring, H):
    eps = 1e-10
    e = max(min(e, 1 - eps), eps)

    H = np.array(H)

    # Step 1: Calculate initial LLRs (R)
    R = []
    for i in bitstring:
        i = int(i)
        if i == 1:
            r = np.log(e / (1 - e))
        elif i == 0:
            r = np.log((1 - e) / e)
        else:
            raise ValueError("Bitstring must contain only 0s and 1s")
        R.append(r)

    R = np.array(R)

    # Initialize messages
    M = np.zeros_like(H, dtype=float)
    E = np.zeros_like(H, dtype=float)

    for _ in range(max_iter):
        # Step 2: Variable-to-check messages
        for i in range(H.shape[0]):
            for j in range(H.shape[1]):
                if H[i, j] == 1:
                    M[i, j] = R[j]

        # Step 3: Check-to-variable messages
        for i in range(H.shape[0]):
            for j in range(H.shape[1]):
                if H[i, j] == 1:
                    prod = 1.0
                    for k in range(H.shape[0]):
                        if H[k, j] == 1 and k != i:
                            prod *= np.tanh(M[k, j]/2)

                    numerator = max(1 + prod, eps)
                    denominator = max(1 - prod, eps)
                    E[i, j] = np.log(numerator / denominator)

        # Step 4: Belief update and hard decision
        L = np.zeros(H.shape[1])
        C = np.zeros(H.shape[1])

        for j in range(H.shape[1]):
            L[j] = R[j]
            for i in range(H.shape[0]):
                if H[i, j] == 1:
                    L[j] += E[i, j]
            C[j] = 0 if L[j] >= 0 else 1

        # Step 5: Check if all parity checks are satisfied
        if np.all((H @ C) % 2 == 0):
            break

    return C

#Example
decoder(0.2, 1, [1, 0, 1], [[1, 1, 0], [0, 1, 1]])

